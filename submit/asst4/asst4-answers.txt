1. The ELF magic numbers are the first 4 bytes of the ELF file header. They are 0x7F, 'E', 'L', 'F'.  The ELF file header struct is defined in "src/kern/include/elf.h" as "Elf32_Ehdr". THe magic numbers are a way to quickly identify that this is a ELF format file.

2. These flags are defined by an enumeration in "src/kern/include/uio.h". UIO_USERISPACE refers to user process code, and UIO_USERSPACE refers to user process data. It is important to distinguish userspace data from kernel data (marked as UIO_SYSSPACE), since userspace code and data should not be trusted. Specifically, these flags are primarily used in uio.c, where data marked by UIO_SYSSPACE is data only transferred within the kernel and is manipulated using memmove(), while data marked by UIO_USERSPACE/UIO_USERISPACE is manipulated using copyin/copyout.

3. Dunno

4. We need to call vfs_close() because we also call vfs_open() at the beginning the function. vfs_open() allocates memory and increases the file reference counter. Since runprogram() does not return but just goes into userspace, we must free the resources used by doing vfs_open() by doing vfs_close(), to prevent memory leaks and to ensure that the file reference counter is in sync. We don't need the file open anyways, since the new userspace process created by runprogram() will execute the file from the pointer "entrypoint" passed to "enter_new_process()" since the contents of the file have already been loaded into a new address space by the loadelf() function. 

5. The function is enter_new_process() at "src/kern/arch/mips/locore/trap.c". enter_new_process() makes the processor switch to usermode. This function is machine dependent as it called the function mips_usermode() which proceeds to call the function asm_usermode() located in "src/kern/arch/mips/locore/exception-mips.S" which is written in assembly, and that makes it inherrently machine-dependent.

6. The functions copyin() and copyout() are both defined in "src/kern/vm/copyinout.c", while memmove() is defined in "src/common/libc/string/memmove.c". copyin() and copyout() cannot be implemented the same way as memmove() because copyin() and copyout() handle data copies between userspace and kernel, and thus additional features are needed such as checking for invalid src and dst userspace addresses, as we don't trust information from userspace. 

7. userptr_t is defined in "src/kern/include/types.h" and the description states that it is a pointer to one-byte struct. This is done to distinguish a userspace pointer from other pointer types.

8. The exception code for a system call is 8, defined by EX_SYS macro in "src/kern/arch/mips/include/trapeframe.h"

9. The size of a MIPS instruction is 4 bytes. This is evidenced by "src/kern/arch/mips/syscall/syscall.c" at the comments at line 136, where the function increments the program counter of the trapframe by 4 bytes shortly before returning to avoid repeating the syscall instruction. 

10. The current implementation of kill_curthread() is to create a kernel panic, which is not the correct thing to do to handle bad or misbehaved user programs. Part of the reason why the kernel exists is to make sure badly behaved user programs don't bring down the entire system along with other processes unrelated to the poorly behaving user program. The current implementation of kill_curthread() also doesn't actually kill the badly-behaving user program in question, which is what we would otherwise expect kill_curthread() to do.

11. 




